<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ebs-ds: ds/bytebuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ebs-ds<span id="projectnumber">&#160;0.3.2</span>
   </div>
   <div id="projectbrief">Assorted low-level datastructures used by higher level EBS libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('bytebuf_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bytebuf.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Interface and usage of bytebuf buffers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bytebuf.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h__incl.svg" width="114" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h__dep__incl.svg" width="114" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="bytebuf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:struct_b_y_t_e_b_u_f" id="r_struct_b_y_t_e_b_u_f"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#struct_b_y_t_e_b_u_f">BYTEBUF</a></td></tr>
<tr class="memdesc:struct_b_y_t_e_b_u_f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary bytebuf struct typedef.  <a href="bytebuf_8h.html#struct_b_y_t_e_b_u_f">More...</a><br /></td></tr>
<tr class="separator:struct_b_y_t_e_b_u_f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Generic Write Tokens</div></td></tr>
<tr class="memitem:a69de2584026d02354927318a233f2a2c" id="r_a69de2584026d02354927318a233f2a2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a69de2584026d02354927318a233f2a2c">BYTEBUF_LOCK_OPEN</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a69de2584026d02354927318a233f2a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41106d7b99bc7687ec3330f534fdb3e" id="r_ab41106d7b99bc7687ec3330f534fdb3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#ab41106d7b99bc7687ec3330f534fdb3e">BYTEBUF_TOKEN_PRINT</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ab41106d7b99bc7687ec3330f534fdb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d76a6fd7f5e27b870dcefad6ad69b79" id="r_a0d76a6fd7f5e27b870dcefad6ad69b79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a0d76a6fd7f5e27b870dcefad6ad69b79">BYTEBUF_TOKEN_SCHAR</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a0d76a6fd7f5e27b870dcefad6ad69b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8fce8b17c920b5268b88340d4361a482" id="r_a8fce8b17c920b5268b88340d4361a482"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="bytebuf_8h.html#struct_b_y_t_e_b_u_f">BYTEBUF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a></td></tr>
<tr class="memdesc:a8fce8b17c920b5268b88340d4361a482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary bytebuf struct typedef.  <br /></td></tr>
<tr class="separator:a8fce8b17c920b5268b88340d4361a482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6435336351510fb192eac2a46fa6de5b" id="r_a6435336351510fb192eac2a46fa6de5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a6435336351510fb192eac2a46fa6de5b">bytebuf_vInit</a> (uint8_t *bufferp, uint8_t size, <a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp)</td></tr>
<tr class="separator:a6435336351510fb192eac2a46fa6de5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8c9d0a2eb3ddb74f5b82f3f54dadbb" id="r_a3c8c9d0a2eb3ddb74f5b82f3f54dadbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a3c8c9d0a2eb3ddb74f5b82f3f54dadbb">bytebuf_vFlush</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp)</td></tr>
<tr class="separator:a3c8c9d0a2eb3ddb74f5b82f3f54dadbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c22babb7b82416a77a1df0499e311b" id="r_a94c22babb7b82416a77a1df0499e311b"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a94c22babb7b82416a77a1df0499e311b">bytebuf_cPopulation</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp)</td></tr>
<tr class="separator:a94c22babb7b82416a77a1df0499e311b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25f027e432cc5d5fb84b3032da02705" id="r_ae25f027e432cc5d5fb84b3032da02705"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#ae25f027e432cc5d5fb84b3032da02705">bytebuf_cGetFree</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp)</td></tr>
<tr class="separator:ae25f027e432cc5d5fb84b3032da02705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c93fef714bd3ab4ea01fc441e3ed84" id="r_a97c93fef714bd3ab4ea01fc441e3ed84"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a97c93fef714bd3ab4ea01fc441e3ed84">bytebuf_cPushChunkLen</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t *past_rollover)</td></tr>
<tr class="memdesc:a97c93fef714bd3ab4ea01fc441e3ed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that can be written contiguously. You still need to acquire a lock if you want to write into it.  <br /></td></tr>
<tr class="separator:a97c93fef714bd3ab4ea01fc441e3ed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84760dae59cf39e85e3c0131305ef814" id="r_a84760dae59cf39e85e3c0131305ef814"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a84760dae59cf39e85e3c0131305ef814">bytebuf_cPopChunkLen</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t *at_rollover)</td></tr>
<tr class="memdesc:a84760dae59cf39e85e3c0131305ef814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that can be read contiguously.  <br /></td></tr>
<tr class="separator:a84760dae59cf39e85e3c0131305ef814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3462d78c7ca27058acbe7e7db71d4f0" id="r_ae3462d78c7ca27058acbe7e7db71d4f0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t length, uint8_t token)</td></tr>
<tr class="separator:ae3462d78c7ca27058acbe7e7db71d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01457594715ba04c6f96d142af5789be" id="r_a01457594715ba04c6f96d142af5789be"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a01457594715ba04c6f96d142af5789be">bytebuf_cPushReqBlindLock</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t token)</td></tr>
<tr class="separator:a01457594715ba04c6f96d142af5789be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10797a68033c23bd9be90537ebb73ed" id="r_ab10797a68033c23bd9be90537ebb73ed"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#ab10797a68033c23bd9be90537ebb73ed">bytebuf_cPushRelinquishLock</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t token)</td></tr>
<tr class="separator:ab10797a68033c23bd9be90537ebb73ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e83f78644c501d12a13d89bfb8bab8" id="r_a59e83f78644c501d12a13d89bfb8bab8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a59e83f78644c501d12a13d89bfb8bab8">bytebuf_cWriteByte</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t byte)</td></tr>
<tr class="separator:a59e83f78644c501d12a13d89bfb8bab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e4a79712d180cd935f8e91156caf2b" id="r_a16e4a79712d180cd935f8e91156caf2b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a16e4a79712d180cd935f8e91156caf2b">bytebuf_cPushByte</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t byte, uint8_t token)</td></tr>
<tr class="separator:a16e4a79712d180cd935f8e91156caf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d45e8f10a100b947487879e9abff800" id="r_a3d45e8f10a100b947487879e9abff800"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a3d45e8f10a100b947487879e9abff800">bytebuf_cPushLen</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, void *sp, uint8_t len, uint8_t token)</td></tr>
<tr class="separator:a3d45e8f10a100b947487879e9abff800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae493018e602dd45678b52d7b7f095705" id="r_ae493018e602dd45678b52d7b7f095705"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#ae493018e602dd45678b52d7b7f095705">bytebuf_cPopByte</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp)</td></tr>
<tr class="separator:ae493018e602dd45678b52d7b7f095705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512c5335eef0d9c18059bacb340bc45" id="r_a5512c5335eef0d9c18059bacb340bc45"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a5512c5335eef0d9c18059bacb340bc45">bytebuf_cPopLen</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, void *dp, uint8_t len)</td></tr>
<tr class="separator:a5512c5335eef0d9c18059bacb340bc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a37e09e092e61d367206fffe2f4d31" id="r_ae0a37e09e092e61d367206fffe2f4d31"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#ae0a37e09e092e61d367206fffe2f4d31">bytebuf_cCopyLen</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, void *dp, uint8_t len)</td></tr>
<tr class="separator:ae0a37e09e092e61d367206fffe2f4d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7421f4d90d80d0f61de5758df5115f2c" id="r_a7421f4d90d80d0f61de5758df5115f2c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8h.html#a7421f4d90d80d0f61de5758df5115f2c">bytebuf_cPopChunk</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t len)</td></tr>
<tr class="memdesc:a7421f4d90d80d0f61de5758df5115f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the next <code>n</code> outbytes as handled. This function is intended to be used with DMA or other functions which read the array in the background. After the read is complete, the buffer should be informed via this function that the read data can be discarded from the buffer. ,.  <br /></td></tr>
<tr class="separator:a7421f4d90d80d0f61de5758df5115f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface and usage of bytebuf buffers. </p>
<p>This library provides a <a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482" title="Primary bytebuf struct typedef.">bytebuf</a> structure and associated functions to implement a circular byte buffer. The design of the buffer is intended to support continuous byte-wide datastreams. A simple locking mechanism for writes is included.</p>
<p>The typical application of such a buffer is when one or more data sources (producers) are writing to a single sink (consumer). In the general case, the buffer is instantiated at and by the consumer, while the producers use their respective tokens to write to the buffer.</p>
<p>While errors are reported, for optimal use implementations should ensure that the buffers are large enough for the consumers to handle all of the produced data before an overflow occurs.</p>
<p>A bytebuf buffer can be at-most 255 bytes long. For longer buffers, some datatypes need to be changed from uint8_t to uint16_t. This will have a performance penalty on uCs with an 8-bit bus.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8c.html" title="Implementation of the bytebuf interface.">bytebuf.c</a> </dd></dl>

<p class="definition">Definition in file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_b_y_t_e_b_u_f" id="struct_b_y_t_e_b_u_f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_b_y_t_e_b_u_f">&#9670;&#160;</a></span>BYTEBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BYTEBUF</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Primary bytebuf struct typedef. </p>
<p>The core of the bytebuf implementation, this type contains bytebuf metadata and control information. This struct should be created by instantiating a variable at the consumer of this type, and calling <a class="el" href="bytebuf_8c.html#a6435336351510fb192eac2a46fa6de5b">bytebuf_vInit()</a>.</p>
<p>This struct does not contain the actual data but has a pointer to a byte array which should be separately created and contains the actual data. </p>

<p class="definition">Definition at line <a class="el" href="bytebuf_8h_source.html#l00077">77</a> of file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a746c5f6f4f11f17ec0e659eeacd158ee" name="a746c5f6f4f11f17ec0e659eeacd158ee"></a>uint8_t *</td>
<td class="fieldname">
_bufp</td>
<td class="fielddoc">
Pointer to the start of the underlying buffer. </td></tr>
<tr><td class="fieldtype">
<a id="ad716016e1cf4cd4acc1a66085e32adef" name="ad716016e1cf4cd4acc1a66085e32adef"></a>uint8_t *</td>
<td class="fieldname">
_inp</td>
<td class="fielddoc">
Pointer to the current write location. </td></tr>
<tr><td class="fieldtype">
<a id="a077ef8a6e6fb9253a5de839ffb85f3a3" name="a077ef8a6e6fb9253a5de839ffb85f3a3"></a>uint8_t</td>
<td class="fieldname">
_lock</td>
<td class="fielddoc">
Token which holds the write lock at present. </td></tr>
<tr><td class="fieldtype">
<a id="a4cfd82cba06dacb68112f1b980021976" name="a4cfd82cba06dacb68112f1b980021976"></a>uint8_t</td>
<td class="fieldname">
_locklen</td>
<td class="fielddoc">
Number of additional bytes for which the lock is valid. </td></tr>
<tr><td class="fieldtype">
<a id="a9e486cb9bd9452eed625572da9a000a1" name="a9e486cb9bd9452eed625572da9a000a1"></a>uint8_t *</td>
<td class="fieldname">
_outp</td>
<td class="fielddoc">
Pointer to the current read location. </td></tr>
<tr><td class="fieldtype">
<a id="ae19f874cbcb138a36d3b2ad9693b7d60" name="ae19f874cbcb138a36d3b2ad9693b7d60"></a>volatile uint8_t</td>
<td class="fieldname">
_population</td>
<td class="fielddoc">
Number of bytes presently in the buffer. </td></tr>
<tr><td class="fieldtype">
<a id="aaa049a794bf092e892763bad507598b5" name="aaa049a794bf092e892763bad507598b5"></a>uint8_t</td>
<td class="fieldname">
_size</td>
<td class="fielddoc">
Size of buffer. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a69de2584026d02354927318a233f2a2c" name="a69de2584026d02354927318a233f2a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69de2584026d02354927318a233f2a2c">&#9670;&#160;</a></span>BYTEBUF_LOCK_OPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTEBUF_LOCK_OPEN&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bytebuf_8h_source.html#l00058">58</a> of file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>

</div>
</div>
<a id="ab41106d7b99bc7687ec3330f534fdb3e" name="ab41106d7b99bc7687ec3330f534fdb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41106d7b99bc7687ec3330f534fdb3e">&#9670;&#160;</a></span>BYTEBUF_TOKEN_PRINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTEBUF_TOKEN_PRINT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bytebuf_8h_source.html#l00059">59</a> of file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>

</div>
</div>
<a id="a0d76a6fd7f5e27b870dcefad6ad69b79" name="a0d76a6fd7f5e27b870dcefad6ad69b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d76a6fd7f5e27b870dcefad6ad69b79">&#9670;&#160;</a></span>BYTEBUF_TOKEN_SCHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTEBUF_TOKEN_SCHAR&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bytebuf_8h_source.html#l00060">60</a> of file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8fce8b17c920b5268b88340d4361a482" name="a8fce8b17c920b5268b88340d4361a482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fce8b17c920b5268b88340d4361a482">&#9670;&#160;</a></span>bytebuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="bytebuf_8h.html#struct_b_y_t_e_b_u_f">BYTEBUF</a> <a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Primary bytebuf struct typedef. </p>
<p>The core of the bytebuf implementation, this type contains bytebuf metadata and control information. This struct should be created by instantiating a variable at the consumer of this type, and calling <a class="el" href="bytebuf_8c.html#a6435336351510fb192eac2a46fa6de5b">bytebuf_vInit()</a>.</p>
<p>This struct does not contain the actual data but has a pointer to a byte array which should be separately created and contains the actual data. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae0a37e09e092e61d367206fffe2f4d31" name="ae0a37e09e092e61d367206fffe2f4d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a37e09e092e61d367206fffe2f4d31">&#9670;&#160;</a></span>bytebuf_cCopyLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cCopyLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a length of data from a bytebuf using the platform's memcpy function.</p>
<p>You should ensure that that number of bytes actually exists in the buffer to be read. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#a94c22babb7b82416a77a1df0499e311b">bytebuf_cPopulation()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">dp</td><td>Pointer to the destination buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed read, 1 for successful copy. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00218">218</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00080">BYTEBUF::_outp</a>, <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, and <a class="el" href="bytebuf_8h_source.html#l00167">bytebuf_cPopChunkLen()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_ae0a37e09e092e61d367206fffe2f4d31_cgraph.svg" width="376" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae25f027e432cc5d5fb84b3032da02705" name="ae25f027e432cc5d5fb84b3032da02705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25f027e432cc5d5fb84b3032da02705">&#9670;&#160;</a></span>bytebuf_cGetFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t bytebuf_cGetFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of bytes that can be written into the buffer right now. You still need to acquire a lock if you want to write into it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of empty bytes left in the buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8h_source.html#l00126">126</a> of file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, and <a class="el" href="bytebuf_8h_source.html#l00082">BYTEBUF::_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bytebuf_8c_source.html#l00072">bytebuf_cPushReqBlindLock()</a>, <a class="el" href="bytebuf_8c_source.html#l00057">bytebuf_cPushReqLock()</a>, and <a class="el" href="bytebuf_8c_source.html#l00102">bytebuf_cWriteByte()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_ae25f027e432cc5d5fb84b3032da02705_icgraph.svg" width="402" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae493018e602dd45678b52d7b7f095705" name="ae493018e602dd45678b52d7b7f095705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae493018e602dd45678b52d7b7f095705">&#9670;&#160;</a></span>bytebuf_cPopByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPopByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop a byte from the bytebuf. You should make sure that there actually is a byte to be read first. </p><dl class="section see"><dt>See also</dt><dd>cbytebuf_population() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte that got popped, or 0 by default if there wasn't one. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>return value of 0 does not necessarily mean an error occured. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00180">180</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00080">BYTEBUF::_outp</a>, <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, and <a class="el" href="bytebuf_8h_source.html#l00082">BYTEBUF::_size</a>.</p>

</div>
</div>
<a id="a7421f4d90d80d0f61de5758df5115f2c" name="a7421f4d90d80d0f61de5758df5115f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7421f4d90d80d0f61de5758df5115f2c">&#9670;&#160;</a></span>bytebuf_cPopChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPopChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the next <code>n</code> outbytes as handled. This function is intended to be used with DMA or other functions which read the array in the background. After the read is complete, the buffer should be informed via this function that the read data can be discarded from the buffer. ,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#a84760dae59cf39e85e3c0131305ef814" title="Return the number of bytes that can be read contiguously.">bytebuf_cPopChunkLen()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes that should be popped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if insufficient bytes to pop, the number of bytes popped otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00236">236</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00080">BYTEBUF::_outp</a>, <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, and <a class="el" href="bytebuf_8h_source.html#l00167">bytebuf_cPopChunkLen()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a7421f4d90d80d0f61de5758df5115f2c_cgraph.svg" width="384" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a84760dae59cf39e85e3c0131305ef814" name="a84760dae59cf39e85e3c0131305ef814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84760dae59cf39e85e3c0131305ef814">&#9670;&#160;</a></span>bytebuf_cPopChunkLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t bytebuf_cPopChunkLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>at_rollover</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes that can be read contiguously. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#a7421f4d90d80d0f61de5758df5115f2c" title="Mark the next n outbytes as handled. This function is intended to be used with DMA or other functions...">bytebuf_cPopChunk()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">at_rollover</td><td>Pointer to uint8_t in which to store rollover flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that can be read contiguously. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8h_source.html#l00167">167</a> of file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bytebuf_8c_source.html#l00218">bytebuf_cCopyLen()</a>, <a class="el" href="bytebuf_8c_source.html#l00236">bytebuf_cPopChunk()</a>, and <a class="el" href="bytebuf_8c_source.html#l00197">bytebuf_cPopLen()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a84760dae59cf39e85e3c0131305ef814_icgraph.svg" width="384" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5512c5335eef0d9c18059bacb340bc45" name="a5512c5335eef0d9c18059bacb340bc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5512c5335eef0d9c18059bacb340bc45">&#9670;&#160;</a></span>bytebuf_cPopLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPopLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop a length of data from a bytebuf using the platform's memcpy function.</p>
<p>You should ensure that that number of bytes actually exists in the buffer to be read. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#a94c22babb7b82416a77a1df0499e311b">bytebuf_cPopulation()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">dp</td><td>Pointer to the destination buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to pop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed read, 1 for successful read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00197">197</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00080">BYTEBUF::_outp</a>, <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, and <a class="el" href="bytebuf_8h_source.html#l00167">bytebuf_cPopChunkLen()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a5512c5335eef0d9c18059bacb340bc45_cgraph.svg" width="367" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a94c22babb7b82416a77a1df0499e311b" name="a94c22babb7b82416a77a1df0499e311b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c22babb7b82416a77a1df0499e311b">&#9670;&#160;</a></span>bytebuf_cPopulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t bytebuf_cPopulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of bytes present in the buffer to be read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes left in the buffer to be read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8h_source.html#l00112">112</a> of file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>.</p>

</div>
</div>
<a id="a16e4a79712d180cd935f8e91156caf2b" name="a16e4a79712d180cd935f8e91156caf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e4a79712d180cd935f8e91156caf2b">&#9670;&#160;</a></span>bytebuf_cPushByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push a single byte into the bytebuf. You should already hold the write lock to do this. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">byte</td><td>Byte to be written in. </td></tr>
    <tr><td class="paramname">token</td><td>Identifier against which you own the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed write, 1 for successful write. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00128">128</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00079">BYTEBUF::_inp</a>, <a class="el" href="bytebuf_8h_source.html#l00083">BYTEBUF::_lock</a>, <a class="el" href="bytebuf_8h_source.html#l00084">BYTEBUF::_locklen</a>, <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, <a class="el" href="bytebuf_8h_source.html#l00082">BYTEBUF::_size</a>, and <a class="el" href="bytebuf_8h_source.html#l00058">BYTEBUF_LOCK_OPEN</a>.</p>

</div>
</div>
<a id="a97c93fef714bd3ab4ea01fc441e3ed84" name="a97c93fef714bd3ab4ea01fc441e3ed84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c93fef714bd3ab4ea01fc441e3ed84">&#9670;&#160;</a></span>bytebuf_cPushChunkLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t bytebuf_cPushChunkLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>past_rollover</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes that can be written contiguously. You still need to acquire a lock if you want to write into it. </p>
<dl class="section see"><dt>See also</dt><dd>bytebuf_cPushChunk() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">past_rollover</td><td>Pointer to uint8_t in which to store rollover flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that can be written contiguously. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8h_source.html#l00142">142</a> of file <a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, and <a class="el" href="bytebuf_8h_source.html#l00082">BYTEBUF::_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bytebuf_8c_source.html#l00154">bytebuf_cPushLen()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a97c93fef714bd3ab4ea01fc441e3ed84_icgraph.svg" width="380" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3d45e8f10a100b947487879e9abff800" name="a3d45e8f10a100b947487879e9abff800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d45e8f10a100b947487879e9abff800">&#9670;&#160;</a></span>bytebuf_cPushLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push a length of data into a bytebuf. You should already hold the write lock to do this. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">sp</td><td>Pointer to the source buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to push in. </td></tr>
    <tr><td class="paramname">token</td><td>Identifier against which you own the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed write, 1 for successful write. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00154">154</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00079">BYTEBUF::_inp</a>, <a class="el" href="bytebuf_8h_source.html#l00083">BYTEBUF::_lock</a>, <a class="el" href="bytebuf_8h_source.html#l00084">BYTEBUF::_locklen</a>, <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, <a class="el" href="bytebuf_8h_source.html#l00142">bytebuf_cPushChunkLen()</a>, and <a class="el" href="bytebuf_8h_source.html#l00058">BYTEBUF_LOCK_OPEN</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a3d45e8f10a100b947487879e9abff800_cgraph.svg" width="380" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab10797a68033c23bd9be90537ebb73ed" name="ab10797a68033c23bd9be90537ebb73ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10797a68033c23bd9be90537ebb73ed">&#9670;&#160;</a></span>bytebuf_cPushRelinquishLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushRelinquishLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relinquish a write lock on a bytebuf. Actual writing is done using other functions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">token</td><td>An identifier against which the lock was issued. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for incorrect token, 1 for lock relinquished, 2 for already open. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00089">89</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00058">BYTEBUF_LOCK_OPEN</a>.</p>

</div>
</div>
<a id="a01457594715ba04c6f96d142af5789be" name="a01457594715ba04c6f96d142af5789be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01457594715ba04c6f96d142af5789be">&#9670;&#160;</a></span>bytebuf_cPushReqBlindLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushReqBlindLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request a write lock on a bytebuf for an unspecified length. Actual writing is done using other functions. </p><dl class="section see"><dt>See also</dt><dd>bytebuf_cPush() </dd>
<dd>
<a class="el" href="bytebuf_8h.html#a3d45e8f10a100b947487879e9abff800">bytebuf_cPushLen()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">token</td><td>An identifier against which to issue the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for lock denied, number of characters free for granted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00072">72</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00126">bytebuf_cGetFree()</a>, and <a class="el" href="bytebuf_8h_source.html#l00058">BYTEBUF_LOCK_OPEN</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a01457594715ba04c6f96d142af5789be_cgraph.svg" width="402" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae3462d78c7ca27058acbe7e7db71d4f0" name="ae3462d78c7ca27058acbe7e7db71d4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3462d78c7ca27058acbe7e7db71d4f0">&#9670;&#160;</a></span>bytebuf_cPushReqLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushReqLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request a write lock on a bytebuf for a specific length. Actual writing is done using other functions. </p><dl class="section see"><dt>See also</dt><dd>bytebuf_cPush() </dd>
<dd>
<a class="el" href="bytebuf_8h.html#a3d45e8f10a100b947487879e9abff800">bytebuf_cPushLen()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes you want to write. </td></tr>
    <tr><td class="paramname">token</td><td>An identifier against which to issue the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for lock denied, 1 for lock issued. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00057">57</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00126">bytebuf_cGetFree()</a>, and <a class="el" href="bytebuf_8h_source.html#l00058">BYTEBUF_LOCK_OPEN</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_ae3462d78c7ca27058acbe7e7db71d4f0_cgraph.svg" width="368" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a59e83f78644c501d12a13d89bfb8bab8" name="a59e83f78644c501d12a13d89bfb8bab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e83f78644c501d12a13d89bfb8bab8">&#9670;&#160;</a></span>bytebuf_cWriteByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cWriteByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a single byte into the bytebuf, clobbering the oldest value in the buffer if there isn't room. Locking isn't used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">byte</td><td>Byte to be written in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed write, 1 for successful write. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00102">102</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00079">BYTEBUF::_inp</a>, <a class="el" href="bytebuf_8h_source.html#l00080">BYTEBUF::_outp</a>, <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, <a class="el" href="bytebuf_8h_source.html#l00082">BYTEBUF::_size</a>, and <a class="el" href="bytebuf_8h_source.html#l00126">bytebuf_cGetFree()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a59e83f78644c501d12a13d89bfb8bab8_cgraph.svg" width="347" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3c8c9d0a2eb3ddb74f5b82f3f54dadbb" name="a3c8c9d0a2eb3ddb74f5b82f3f54dadbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8c9d0a2eb3ddb74f5b82f3f54dadbb">&#9670;&#160;</a></span>bytebuf_vFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bytebuf_vFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush a buffer and reset it to its pristine state. </p><dl class="section warning"><dt>Warning</dt><dd>Any locks held on the buffer will disappear and holder is not informed. </dd>
<dd>
Any data present in the data will be lost. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00046">46</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00058">BYTEBUF_LOCK_OPEN</a>.</p>

<p class="reference">Referenced by <a class="el" href="bytebuf_8c_source.html#l00037">bytebuf_vInit()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a3c8c9d0a2eb3ddb74f5b82f3f54dadbb_icgraph.svg" width="290" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6435336351510fb192eac2a46fa6de5b" name="a6435336351510fb192eac2a46fa6de5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6435336351510fb192eac2a46fa6de5b">&#9670;&#160;</a></span>bytebuf_vInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bytebuf_vInit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a bytebuf structure using an externally supplied (and allocated) memory array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferp</td><td>Pointer to the array; should be in the heap and not in a task stack. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the array. Beware : we have no good way to check this later. </td></tr>
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure to be initialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00037">37</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8c_source.html#l00046">bytebuf_vFlush()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8h_a6435336351510fb192eac2a46fa6de5b_cgraph.svg" width="290" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_79d8f15e560b8d0f485bc841cb37e482.html">ds</a></li><li class="navelem"><a class="el" href="bytebuf_8h.html">bytebuf.h</a></li>
    <li class="footer">Generated on Thu Jan 16 2025 20:06:16 for ebs-ds by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
