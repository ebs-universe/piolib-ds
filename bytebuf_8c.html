<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ebs-ds: ds/bytebuf.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ebs-ds
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
   <div id="projectbrief">Assorted low-level datastructures used by higher level EBS libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('bytebuf_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bytebuf.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the bytebuf interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="bytebuf_8h_source.html">bytebuf.h</a>&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bytebuf.c:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8c__incl.svg" width="190" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="bytebuf_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6435336351510fb192eac2a46fa6de5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#a6435336351510fb192eac2a46fa6de5b">bytebuf_vInit</a> (uint8_t *bufferp, uint8_t size, <a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp)</td></tr>
<tr class="separator:a6435336351510fb192eac2a46fa6de5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8c9d0a2eb3ddb74f5b82f3f54dadbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#a3c8c9d0a2eb3ddb74f5b82f3f54dadbb">bytebuf_vFlush</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp)</td></tr>
<tr class="separator:a3c8c9d0a2eb3ddb74f5b82f3f54dadbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3462d78c7ca27058acbe7e7db71d4f0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t length, uint8_t token)</td></tr>
<tr class="separator:ae3462d78c7ca27058acbe7e7db71d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01457594715ba04c6f96d142af5789be"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#a01457594715ba04c6f96d142af5789be">bytebuf_cPushReqBlindLock</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t token)</td></tr>
<tr class="separator:a01457594715ba04c6f96d142af5789be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10797a68033c23bd9be90537ebb73ed"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#ab10797a68033c23bd9be90537ebb73ed">bytebuf_cPushRelinquishLock</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t token)</td></tr>
<tr class="separator:ab10797a68033c23bd9be90537ebb73ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e83f78644c501d12a13d89bfb8bab8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#a59e83f78644c501d12a13d89bfb8bab8">bytebuf_cWriteByte</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t byte)</td></tr>
<tr class="separator:a59e83f78644c501d12a13d89bfb8bab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e4a79712d180cd935f8e91156caf2b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#a16e4a79712d180cd935f8e91156caf2b">bytebuf_cPushByte</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t byte, uint8_t token)</td></tr>
<tr class="separator:a16e4a79712d180cd935f8e91156caf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d45e8f10a100b947487879e9abff800"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#a3d45e8f10a100b947487879e9abff800">bytebuf_cPushLen</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, void *sp, uint8_t len, uint8_t token)</td></tr>
<tr class="separator:a3d45e8f10a100b947487879e9abff800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae493018e602dd45678b52d7b7f095705"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#ae493018e602dd45678b52d7b7f095705">bytebuf_cPopByte</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp)</td></tr>
<tr class="separator:ae493018e602dd45678b52d7b7f095705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512c5335eef0d9c18059bacb340bc45"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#a5512c5335eef0d9c18059bacb340bc45">bytebuf_cPopLen</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, void *dp, uint8_t len)</td></tr>
<tr class="separator:a5512c5335eef0d9c18059bacb340bc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a37e09e092e61d367206fffe2f4d31"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#ae0a37e09e092e61d367206fffe2f4d31">bytebuf_cCopyLen</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, void *dp, uint8_t len)</td></tr>
<tr class="separator:ae0a37e09e092e61d367206fffe2f4d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7421f4d90d80d0f61de5758df5115f2c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytebuf_8c.html#a7421f4d90d80d0f61de5758df5115f2c">bytebuf_cPopChunk</a> (<a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *bytebufp, uint8_t len)</td></tr>
<tr class="memdesc:a7421f4d90d80d0f61de5758df5115f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the next <code>n</code> outbytes as handled. This function is intended to be used with DMA or other functions which read the array in the background. After the read is complete, the buffer should be informed via this function that the read data can be discarded from the buffer. ,.  <a href="bytebuf_8c.html#a7421f4d90d80d0f61de5758df5115f2c">More...</a><br /></td></tr>
<tr class="separator:a7421f4d90d80d0f61de5758df5115f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the bytebuf interface. </p>
<p>See <a class="el" href="bytebuf_8h.html" title="Interface and usage of bytebuf buffers.">bytebuf.h</a> for usage documentation. Implementation documentation should be added to this file as some point.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html" title="Interface and usage of bytebuf buffers.">bytebuf.h</a> </dd></dl>

<p class="definition">Definition in file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae0a37e09e092e61d367206fffe2f4d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a37e09e092e61d367206fffe2f4d31">&#9670;&nbsp;</a></span>bytebuf_cCopyLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cCopyLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a length of data from a bytebuf using the platform's memcpy function.</p>
<p>You should ensure that that number of bytes actually exists in the buffer to be read. </p><dl class="section see"><dt>See also</dt><dd>bytebuf_cPopulation() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">dp</td><td>Pointer to the destination buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed read, 1 for successful copy. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00218">218</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>.</p>

</div>
</div>
<a id="ae493018e602dd45678b52d7b7f095705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae493018e602dd45678b52d7b7f095705">&#9670;&nbsp;</a></span>bytebuf_cPopByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPopByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop a byte from the bytebuf. You should make sure that there actually is a byte to be read first. </p><dl class="section see"><dt>See also</dt><dd>cbytebuf_population() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte that got popped, or 0 by default if there wasn't one. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>return value of 0 does not necessarily mean an error occured. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00180">180</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00080">BYTEBUF::_outp</a>, <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>, and <a class="el" href="bytebuf_8h_source.html#l00082">BYTEBUF::_size</a>.</p>

</div>
</div>
<a id="a7421f4d90d80d0f61de5758df5115f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7421f4d90d80d0f61de5758df5115f2c">&#9670;&nbsp;</a></span>bytebuf_cPopChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPopChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the next <code>n</code> outbytes as handled. This function is intended to be used with DMA or other functions which read the array in the background. After the read is complete, the buffer should be informed via this function that the read data can be discarded from the buffer. ,. </p>
<dl class="section see"><dt>See also</dt><dd>bytebuf_cPopChunkLen() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes that should be popped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if insufficient bytes to pop, the number of bytes popped otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00236">236</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>.</p>

</div>
</div>
<a id="a5512c5335eef0d9c18059bacb340bc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5512c5335eef0d9c18059bacb340bc45">&#9670;&nbsp;</a></span>bytebuf_cPopLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPopLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop a length of data from a bytebuf using the platform's memcpy function.</p>
<p>You should ensure that that number of bytes actually exists in the buffer to be read. </p><dl class="section see"><dt>See also</dt><dd>bytebuf_cPopulation() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">dp</td><td>Pointer to the destination buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to pop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed read, 1 for successful read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00197">197</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00081">BYTEBUF::_population</a>.</p>

</div>
</div>
<a id="a16e4a79712d180cd935f8e91156caf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e4a79712d180cd935f8e91156caf2b">&#9670;&nbsp;</a></span>bytebuf_cPushByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push a single byte into the bytebuf. You should already hold the write lock to do this. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">byte</td><td>Byte to be written in. </td></tr>
    <tr><td class="paramname">token</td><td>Identifier against which you own the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed write, 1 for successful write. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00128">128</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00078">BYTEBUF::_bufp</a>, <a class="el" href="bytebuf_8h_source.html#l00079">BYTEBUF::_inp</a>, <a class="el" href="bytebuf_8h_source.html#l00083">BYTEBUF::_lock</a>, and <a class="el" href="bytebuf_8h_source.html#l00082">BYTEBUF::_size</a>.</p>

</div>
</div>
<a id="a3d45e8f10a100b947487879e9abff800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d45e8f10a100b947487879e9abff800">&#9670;&nbsp;</a></span>bytebuf_cPushLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push a length of data into a bytebuf. You should already hold the write lock to do this. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">sp</td><td>Pointer to the source buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to push in. </td></tr>
    <tr><td class="paramname">token</td><td>Identifier against which you own the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed write, 1 for successful write. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00154">154</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8h_source.html#l00083">BYTEBUF::_lock</a>, and <a class="el" href="bytebuf_8h_source.html#l00084">BYTEBUF::_locklen</a>.</p>

</div>
</div>
<a id="ab10797a68033c23bd9be90537ebb73ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10797a68033c23bd9be90537ebb73ed">&#9670;&nbsp;</a></span>bytebuf_cPushRelinquishLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushRelinquishLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relinquish a write lock on a bytebuf. Actual writing is done using other functions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="bytebuf_8h.html#ae3462d78c7ca27058acbe7e7db71d4f0">bytebuf_cPushReqLock()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">token</td><td>An identifier against which the lock was issued. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for incorrect token, 1 for lock relinquished, 2 for already open. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00089">89</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

</div>
</div>
<a id="a01457594715ba04c6f96d142af5789be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01457594715ba04c6f96d142af5789be">&#9670;&nbsp;</a></span>bytebuf_cPushReqBlindLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushReqBlindLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request a write lock on a bytebuf for an unspecified length. Actual writing is done using other functions. </p><dl class="section see"><dt>See also</dt><dd>bytebuf_cPush() </dd>
<dd>
<a class="el" href="bytebuf_8h.html#a3d45e8f10a100b947487879e9abff800">bytebuf_cPushLen()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">token</td><td>An identifier against which to issue the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for lock denied, number of characters free for granted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00072">72</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

</div>
</div>
<a id="ae3462d78c7ca27058acbe7e7db71d4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3462d78c7ca27058acbe7e7db71d4f0">&#9670;&nbsp;</a></span>bytebuf_cPushReqLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cPushReqLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request a write lock on a bytebuf for a specific length. Actual writing is done using other functions. </p><dl class="section see"><dt>See also</dt><dd>bytebuf_cPush() </dd>
<dd>
<a class="el" href="bytebuf_8h.html#a3d45e8f10a100b947487879e9abff800">bytebuf_cPushLen()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes you want to write. </td></tr>
    <tr><td class="paramname">token</td><td>An identifier against which to issue the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for lock denied, 1 for lock issued. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00057">57</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

</div>
</div>
<a id="a59e83f78644c501d12a13d89bfb8bab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e83f78644c501d12a13d89bfb8bab8">&#9670;&nbsp;</a></span>bytebuf_cWriteByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bytebuf_cWriteByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a single byte into the bytebuf, clobbering the oldest value in the buffer if there isn't room. Locking isn't used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
    <tr><td class="paramname">byte</td><td>Byte to be written in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for failed write, 1 for successful write. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00102">102</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

</div>
</div>
<a id="a3c8c9d0a2eb3ddb74f5b82f3f54dadbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8c9d0a2eb3ddb74f5b82f3f54dadbb">&#9670;&nbsp;</a></span>bytebuf_vFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bytebuf_vFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush a buffer and reset it to its pristine state. </p><dl class="section warning"><dt>Warning</dt><dd>Any locks held on the buffer will disappear and holder is not informed. </dd>
<dd>
Any data present in the data will be lost. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00046">46</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="bytebuf_8c_source.html#l00037">bytebuf_vInit()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8c_a3c8c9d0a2eb3ddb74f5b82f3f54dadbb_icgraph.svg" width="290" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6435336351510fb192eac2a46fa6de5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6435336351510fb192eac2a46fa6de5b">&#9670;&nbsp;</a></span>bytebuf_vInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bytebuf_vInit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bytebuf_8h.html#a8fce8b17c920b5268b88340d4361a482">bytebuf</a> *&#160;</td>
          <td class="paramname"><em>bytebufp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a bytebuf structure using an externally supplied (and allocated) memory array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferp</td><td>Pointer to the array; should be in the heap and not in a task stack. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the array. Beware : we have no good way to check this later. </td></tr>
    <tr><td class="paramname">bytebufp</td><td>Pointer to the bytebuf structure to be initialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bytebuf_8c_source.html#l00037">37</a> of file <a class="el" href="bytebuf_8c_source.html">bytebuf.c</a>.</p>

<p class="reference">References <a class="el" href="bytebuf_8c_source.html#l00046">bytebuf_vFlush()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bytebuf_8c_a6435336351510fb192eac2a46fa6de5b_cgraph.svg" width="290" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_79d8f15e560b8d0f485bc841cb37e482.html">ds</a></li><li class="navelem"><a class="el" href="bytebuf_8c.html">bytebuf.c</a></li>
    <li class="footer">Generated on Tue May 28 2024 15:09:46 for ebs-ds by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
